#!/usr/bin/env python
# -*- encoding: utf-8 -*-
import os
import os.path
import sys
import argparse
import struct
from Crypto.PublicKey import RSA

class RSATool:
    def __init__(self):
        parser = argparse.ArgumentParser()
        sub_parsers = parser.add_subparsers(help='sub commands')
        info_parser = sub_parsers.add_parser('info', help='show RSA public/private key information')
        info_parser.add_argument('--hex', help='print values in hexadecimal form', action='store_true')
        info_parser.add_argument('infile', nargs='?', type=argparse.FileType('rb'), default=sys.stdin)
        info_parser.set_defaults(func=self.info)
        args = parser.parse_args()
        args.func(args)

    def info(self, args):
        keydata = args.infile.read()
        key = RSA.importKey(keydata)

        print("N = %s" % (hex(key.n)[:-1] if args.hex else str(key.n)))
        print("e = %s" % (hex(key.e)[:-1] if args.hex else str(key.e)))
        if key.has_private():
            print("p = %s" % (hex(key.p)[:-1] if args.hex else str(key.p)))
            print("q = %s" % (hex(key.q)[:-1] if args.hex else str(key.q)))
            print("d = %s" % (hex(key.d)[:-1] if args.hex else str(key.d)))

    def parse_ssh_key(self, data):
        offset = 11
        len_e = struct.unpack('>I', data[offset:offset+4])[0]
        offset += 4
        e = int(data[offset:(offset+len_e)].encode('hex'), 16)
        offset += len_e
        len_N = struct.unpack('>I', data[offset:(offset+4)])[0]
        offset += 4
        N = int(data[offset:(offset+len_N)].encode('hex'), 16)
        return PublicKey(N, e)

    def eq(self, left, right):
        print('%s = %s' % (left, right))


if __name__ == '__main__':
    RSATool()
